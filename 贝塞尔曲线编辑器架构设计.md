# 贝塞尔曲线编辑器架构设计

## 一、整体架构框架

### 1.1 核心模块划分

```
贝塞尔曲线编辑器系统
├── 运行时模块 (Runtime)
│   ├── BezierCurve.cs          - 贝塞尔曲线数据类
│   ├── BezierPoint.cs          - 控制点数据结构
│   └── BezierCurveEvaluator.cs - 曲线求值器
│
├── 编辑器模块 (Editor)
│   ├── BezierCurveEditorWindow.cs    - 主编辑器窗口
│   ├── BezierCurveInspector.cs       - Inspector 绘制器
│   ├── BezierCurveDrawer.cs          - 曲线绘制系统
│   ├── BezierCurveInteraction.cs     - 交互处理系统
│   └── BezierCurveSettings.cs        - 编辑器设置
│
└── 工具模块 (Utilities)
    ├── BezierMath.cs            - 贝塞尔数学计算
    └── BezierCurveSerializer.cs - 序列化工具
```

### 1.2 数据流架构

```
用户操作
    ↓
编辑器窗口 (BezierCurveEditorWindow)
    ↓
交互系统 (BezierCurveInteraction)
    ↓
数据模型 (BezierCurve)
    ↓
序列化 (ScriptableObject / SerializedProperty)
    ↓
运行时使用 (BezierCurve.Evaluate)
```

## 二、技术原理详解

### 2.1 贝塞尔曲线数学原理

#### 2.1.1 三次贝塞尔曲线公式

**标准三次贝塞尔曲线**（4个控制点）：
```
B(t) = (1-t)³P₀ + 3(1-t)²tP₁ + 3(1-t)t²P₂ + t³P₃
其中：
- t ∈ [0, 1] 是参数
- P₀, P₃ 是端点（锚点）
- P₁, P₂ 是控制点（切线方向）
```

**分段贝塞尔曲线**（多段连接）：
```
每段由 4 个点组成：[P₀, P₁, P₂, P₃]
下一段的 P₀ = 上一段的 P₃（连续性）
```

#### 2.1.2 切线计算

**切线方向**：
```
B'(t) = 3(1-t)²(P₁-P₀) + 6(1-t)t(P₂-P₁) + 3t²(P₃-P₂)
```

**在端点处**：
```
B'(0) = 3(P₁-P₀)  // 起点切线
B'(1) = 3(P₃-P₂)  // 终点切线
```

### 2.2 Unity Editor 绘制原理

#### 2.2.1 坐标系转换

**世界坐标 → 屏幕坐标**：
```csharp
// 曲线空间 (0,0) 到 (1,1)
// 屏幕空间 rect 区域
Vector2 CurveToScreen(Vector2 curvePoint, Rect screenRect)
{
    float x = Mathf.Lerp(screenRect.xMin, screenRect.xMax, curvePoint.x);
    float y = Mathf.Lerp(screenRect.yMax, screenRect.yMin, curvePoint.y); // Y轴翻转
    return new Vector2(x, y);
}
```

#### 2.2.2 绘制系统

**使用 Unity Handles API**：
- `Handles.DrawBezier()` - 绘制贝塞尔曲线
- `Handles.DrawLine()` - 绘制辅助线
- `Handles.DrawWireDisc()` - 绘制控制点
- `Handles.PositionHandle()` - 可拖拽的3D手柄（2D投影）

**使用 GUI API**：
- `GUI.DrawTexture()` - 绘制背景网格
- `Event.current` - 处理鼠标事件
- `EditorGUIUtility.AddCursorRect()` - 鼠标样式

### 2.3 交互系统原理

#### 2.3.1 鼠标拾取算法

**点到曲线距离**：
```csharp
// 1. 参数化采样曲线
// 2. 计算鼠标点到采样点的距离
// 3. 找到最小距离点
float DistanceToCurve(Vector2 mousePos, BezierCurve curve, Rect screenRect)
{
    float minDist = float.MaxValue;
    int samples = 100; // 采样精度
    
    for (int i = 0; i < samples; i++)
    {
        float t = i / (float)(samples - 1);
        Vector2 curvePoint = curve.Evaluate(t);
        Vector2 screenPoint = CurveToScreen(curvePoint, screenRect);
        float dist = Vector2.Distance(mousePos, screenPoint);
        minDist = Mathf.Min(minDist, dist);
    }
    
    return minDist;
}
```

**控制点拾取**：
```csharp
// 简单的圆形碰撞检测
bool IsPointInCircle(Vector2 point, Vector2 center, float radius)
{
    return Vector2.Distance(point, center) <= radius;
}
```

#### 2.3.2 拖拽系统

**状态机**：
```
Idle → Hover → Drag → Idle
  ↓      ↓      ↓
检测   高亮   更新位置
```

**拖拽实现**：
```csharp
if (Event.current.type == EventType.MouseDown)
{
    // 检测点击
    selectedPoint = GetPointAtPosition(mousePos);
    if (selectedPoint != null)
        dragState = DragState.Dragging;
}

if (Event.current.type == EventType.MouseDrag && dragState == DragState.Dragging)
{
    // 更新位置
    Vector2 newCurvePos = ScreenToCurve(mousePos, screenRect);
    selectedPoint.position = newCurvePos;
    GUI.changed = true;
}
```

### 2.4 序列化原理

#### 2.4.1 ScriptableObject 方案

**优点**：
- 可以作为资源文件保存
- 支持多对象引用
- 便于版本控制

**实现**：
```csharp
[CreateAssetMenu(fileName = "NewBezierCurve", menuName = "Curves/Bezier Curve")]
public class BezierCurveAsset : ScriptableObject
{
    public BezierCurve curve;
}
```

#### 2.4.2 SerializedProperty 方案

**优点**：
- 直接序列化到 MonoBehaviour
- 支持 Undo/Redo
- Inspector 集成

**实现**：
```csharp
[System.Serializable]
public class BezierCurve
{
    public List<BezierPoint> points = new List<BezierPoint>();
}

[System.Serializable]
public class BezierPoint
{
    public Vector2 position;
    public Vector2 controlIn;
    public Vector2 controlOut;
}
```

### 2.5 性能优化原理

#### 2.5.1 曲线采样缓存

**问题**：每次绘制都重新计算曲线点很耗时

**解决**：缓存采样结果
```csharp
private Vector2[] cachedSamples;
private int cachedSampleCount = 100;

void CacheCurveSamples()
{
    cachedSamples = new Vector2[cachedSampleCount];
    for (int i = 0; i < cachedSampleCount; i++)
    {
        float t = i / (float)(cachedSampleCount - 1);
        cachedSamples[i] = curve.Evaluate(t);
    }
}
```

#### 2.5.2 视口裁剪

**只绘制可见部分**：
```csharp
bool IsPointVisible(Vector2 curvePoint, Rect viewBounds)
{
    return viewBounds.Contains(curvePoint);
}
```

## 三、编辑器布局设计

### 3.1 窗口布局结构

```
┌─────────────────────────────────────────┐
│  Bezier Curve Editor          [×]      │ ← 标题栏
├─────────────────────────────────────────┤
│  [File] [Edit] [View] [Tools]          │ ← 菜单栏
├─────────────────────────────────────────┤
│  ┌──────────────────┐  ┌─────────────┐ │
│  │                  │  │  Properties │ │
│  │                  │  │             │ │
│  │   Curve View     │  │  Point 1:   │ │
│  │   (主绘制区域)    │  │  X: [___]   │ │
│  │                  │  │  Y: [___]   │ │
│  │                  │  │             │ │
│  │                  │  │  Control:   │ │
│  │                  │  │  In:  [___] │ │
│  │                  │  │  Out: [___] │ │
│  └──────────────────┘  └─────────────┘ │
│  ┌───────────────────────────────────┐ │
│  │  Timeline / Preview               │ │ ← 底部预览区
│  └───────────────────────────────────┘ │
└─────────────────────────────────────────┘
```

### 3.2 主绘制区域布局

```
┌─────────────────────────────────────┐
│  [Grid] [Snap] [Lock]  [0.0] [1.0] │ ← 工具栏
├─────────────────────────────────────┤
│                                     │
│   ┌─────────────────────────────┐   │
│   │                             │   │
│   │                             │   │
│   │     曲线绘制区域              │   │
│   │   (带网格背景)                │   │
│   │                             │   │
│   │                             │   │
│   └─────────────────────────────┘   │
│                                     │
│  X: [0.00]  Y: [0.00]  T: [0.00]   │ ← 状态栏
└─────────────────────────────────────┘
```

### 3.3 属性面板布局

```
┌─────────────────────────┐
│  Selected Point         │
├─────────────────────────┤
│  Position:              │
│    X: [0.50]            │
│    Y: [0.50]            │
│                         │
│  Control In:            │
│    X: [0.30]            │
│    Y: [0.40]            │
│    [Auto] [Mirror]      │
│                         │
│  Control Out:           │
│    X: [0.70]            │
│    Y: [0.60]            │
│    [Auto] [Mirror]      │
│                         │
│  [Delete Point]         │
├─────────────────────────┤
│  Curve Settings         │
├─────────────────────────┤
│  Resolution: [100]      │
│  Loop: [ ]              │
│  PreWrap: [Clamp ▼]     │
│  PostWrap: [Clamp ▼]    │
└─────────────────────────┘
```

### 3.4 工具栏设计

**左侧工具组**：
- `[Select]` - 选择工具
- `[Add Point]` - 添加控制点
- `[Delete]` - 删除选中点
- `[Move]` - 移动工具

**中间视图控制**：
- `[Grid]` - 显示/隐藏网格
- `[Snap]` - 吸附到网格
- `[Lock]` - 锁定切线
- `[Auto]` - 自动切线

**右侧缩放控制**：
- `[Zoom In]` `[Zoom Out]` `[Fit]` `[1:1]`
- `[Pan]` - 平移视图

### 3.5 快捷键设计

| 快捷键 | 功能 |
|--------|------|
| `A` | 添加控制点 |
| `Delete` / `X` | 删除选中点 |
| `Ctrl+Z` | 撤销 |
| `Ctrl+Y` | 重做 |
| `Ctrl+C` | 复制 |
| `Ctrl+V` | 粘贴 |
| `Ctrl+A` | 全选 |
| `Space + Drag` | 平移视图 |
| `Mouse Wheel` | 缩放 |
| `F` | 适应窗口 |
| `1` | 选择工具 |
| `2` | 添加点工具 |

## 四、核心类设计

### 4.1 BezierPoint（控制点）

```csharp
[System.Serializable]
public class BezierPoint
{
    [SerializeField] private Vector2 m_Position;
    [SerializeField] private Vector2 m_ControlIn;
    [SerializeField] private Vector2 m_ControlOut;
    [SerializeField] private bool m_AutoTangents;
    [SerializeField] private bool m_MirrorTangents;
    
    public Vector2 position { get; set; }
    public Vector2 controlIn { get; set; }
    public Vector2 controlOut { get; set; }
    public bool autoTangents { get; set; }
    public bool mirrorTangents { get; set; }
}
```

### 4.2 BezierCurve（曲线数据）

```csharp
[System.Serializable]
public class BezierCurve
{
    [SerializeField] private List<BezierPoint> m_Points = new List<BezierPoint>();
    [SerializeField] private bool m_Loop;
    [SerializeField] private int m_Resolution = 100;
    
    public int pointCount => m_Points.Count;
    public bool loop { get; set; }
    public int resolution { get; set; }
    
    public Vector2 Evaluate(float t);
    public void AddPoint(Vector2 position);
    public void RemovePoint(int index);
    public void MovePoint(int index, Vector2 newPosition);
}
```

### 4.3 BezierCurveEditorWindow（编辑器窗口）

```csharp
public class BezierCurveEditorWindow : EditorWindow
{
    private BezierCurve m_Curve;
    private SerializedObject m_SerializedObject;
    private Rect m_CurveArea;
    private Vector2 m_ScrollPosition;
    private int m_SelectedPointIndex = -1;
    private EditMode m_EditMode = EditMode.Select;
    
    enum EditMode { Select, AddPoint, Delete }
    
    [MenuItem("Tools/Bezier Curve Editor")]
    static void OpenWindow() { }
    
    void OnGUI() { }
    void DrawCurveArea() { }
    void HandleInput() { }
    void DrawGrid() { }
    void DrawCurve() { }
    void DrawControlPoints() { }
}
```

## 五、实现步骤

### 5.1 第一阶段：基础数据结构

1. ✅ 创建 `BezierPoint` 类
2. ✅ 创建 `BezierCurve` 类
3. ✅ 实现基础数学计算（`BezierMath.Evaluate`）
4. ✅ 实现序列化支持

### 5.2 第二阶段：编辑器窗口

1. ✅ 创建 `EditorWindow`
2. ✅ 实现基础布局
3. ✅ 添加菜单和工具栏
4. ✅ 实现属性面板

### 5.3 第三阶段：绘制系统

1. ✅ 实现坐标系转换
2. ✅ 绘制网格背景
3. ✅ 绘制贝塞尔曲线
4. ✅ 绘制控制点和切线

### 5.4 第四阶段：交互系统

1. ✅ 实现鼠标拾取
2. ✅ 实现拖拽功能
3. ✅ 实现添加/删除点
4. ✅ 实现切线编辑

### 5.5 第五阶段：高级功能

1. ✅ 实现撤销/重做
2. ✅ 实现复制/粘贴
3. ✅ 实现网格吸附
4. ✅ 实现自动切线
5. ✅ 实现预览功能

## 六、关键技术点

### 6.1 贝塞尔曲线求值

**De Casteljau 算法**（递归）：
```csharp
Vector2 EvaluateBezier(Vector2[] points, float t)
{
    if (points.Length == 1)
        return points[0];
    
    Vector2[] newPoints = new Vector2[points.Length - 1];
    for (int i = 0; i < newPoints.Length; i++)
    {
        newPoints[i] = Vector2.Lerp(points[i], points[i + 1], t);
    }
    
    return EvaluateBezier(newPoints, t);
}
```

**直接公式**（性能更好）：
```csharp
Vector2 EvaluateCubicBezier(Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3, float t)
{
    float u = 1 - t;
    float tt = t * t;
    float uu = u * u;
    float uuu = uu * u;
    float ttt = tt * t;
    
    Vector2 point = uuu * p0;
    point += 3 * uu * t * p1;
    point += 3 * u * tt * p2;
    point += ttt * p3;
    
    return point;
}
```

### 6.2 曲线分段处理

**多段贝塞尔曲线**：
```csharp
Vector2 EvaluateMultiSegment(List<BezierPoint> points, float t, bool loop)
{
    if (points.Count < 2)
        return Vector2.zero;
    
    int segmentCount = loop ? points.Count : points.Count - 1;
    float segmentT = t * segmentCount;
    int segmentIndex = Mathf.FloorToInt(segmentT);
    float localT = segmentT - segmentIndex;
    
    if (loop)
        segmentIndex %= points.Count;
    else
        segmentIndex = Mathf.Clamp(segmentIndex, 0, segmentCount - 1);
    
    BezierPoint p0 = points[segmentIndex];
    BezierPoint p1 = points[(segmentIndex + 1) % points.Count];
    
    return EvaluateCubicBezier(
        p0.position,
        p0.position + p0.controlOut,
        p1.position + p1.controlIn,
        p1.position,
        localT
    );
}
```

### 6.3 切线自动计算

**平滑切线**：
```csharp
void CalculateAutoTangents(BezierPoint point, BezierPoint prev, BezierPoint next)
{
    if (prev == null || next == null)
        return;
    
    Vector2 dir = (next.position - prev.position).normalized;
    float dist = Vector2.Distance(prev.position, next.position) * 0.33f;
    
    point.controlIn = -dir * dist;
    point.controlOut = dir * dist;
}
```

### 6.4 撤销/重做系统

**使用 Undo API**：
```csharp
void MovePoint(int index, Vector2 newPosition)
{
    Undo.RecordObject(this, "Move Bezier Point");
    m_Points[index].position = newPosition;
    EditorUtility.SetDirty(this);
}
```

## 七、扩展功能建议

### 7.1 预设曲线库

- 线性
- 缓入/缓出
- 弹性
- 反弹
- 自定义预设保存/加载

### 7.2 动画预览

- 时间轴控制
- 播放/暂停
- 速度调节
- 循环播放

### 7.3 导出功能

- 导出为 AnimationCurve
- 导出为关键帧数组
- 导出为图片
- 导出为 JSON/XML

### 7.4 高级编辑

- 曲线平滑
- 曲线简化（减少点数）
- 曲线反转
- 曲线缩放/平移
- 多曲线编辑

## 八、参考资源

### 8.1 Unity API 文档

- `EditorWindow` - 编辑器窗口基类
- `Handles` - 场景视图绘制 API
- `Event` - 事件处理
- `SerializedProperty` - 序列化属性
- `Undo` - 撤销系统

### 8.2 数学参考

- 贝塞尔曲线数学公式
- De Casteljau 算法
- 曲线求值优化
- 切线计算

### 8.3 设计参考

- Unity AnimationCurve 编辑器
- Adobe Illustrator 钢笔工具
- Blender 曲线编辑器
- After Effects 关键帧编辑器

---

## 总结

这个架构设计提供了一个完整的贝塞尔曲线编辑器框架，包括：

1. **清晰的分层架构** - 运行时、编辑器、工具模块分离
2. **完整的数学基础** - 贝塞尔曲线计算和优化
3. **直观的UI设计** - 参考专业工具的用户体验
4. **可扩展的结构** - 便于添加新功能

按照这个架构，可以逐步实现一个功能完整、性能优秀的贝塞尔曲线编辑器。


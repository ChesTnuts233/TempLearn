# Unity 生命周期执行顺序说明

本文档详细说明了 Unity 中所有生命周期的实际执行顺序和用途。

## 一、初始化阶段

### 1. Awake
- **调用时机**: 对象创建时立即调用，在所有其他方法之前
- **特点**: 
  - 即使对象未激活也会调用
  - 在 OnEnable 之前调用
  - 用于初始化不依赖其他对象的变量
- **执行顺序**: 最早执行

### 2. OnEnable
- **调用时机**: 对象激活时调用（每次激活都会调用）
- **特点**:
  - 在 Awake 之后，Start 之前（首次激活时）
  - 对象从禁用状态变为激活状态时也会调用
  - 用于订阅事件、启用组件等
- **执行顺序**: Awake → OnEnable

### 3. Start
- **调用时机**: 首次激活后的第一帧调用，在所有 Update 之前
- **特点**:
  - 只在对象首次激活时调用一次
  - 在 Awake 和 OnEnable 之后
  - 用于初始化依赖其他对象的变量
- **执行顺序**: Awake → OnEnable → Start

## 二、物理更新阶段

### 4. FixedUpdate
- **调用时机**: 固定时间间隔调用（默认 0.02 秒，50Hz）
- **特点**:
  - 与物理系统同步，不受帧率影响
  - 在 Update 之前或之后都可能调用（取决于物理时间步长）
  - 用于物理相关的计算（Rigidbody 操作等）
- **执行顺序**: 与 Update 并行，但时间步长固定

## 三、常规更新阶段

### 5. Update
- **调用时机**: 每帧调用一次（帧率相关）
- **特点**:
  - 在 FixedUpdate 之后（如果该帧有 FixedUpdate）
  - 在 LateUpdate 之前
  - 用于游戏逻辑、输入处理等
- **执行顺序**: FixedUpdate → Update

### 6. LateUpdate
- **调用时机**: 每帧在 Update 之后调用
- **特点**:
  - 在所有 Update 执行完毕后调用
  - 在 OnAnimatorMove 之前
  - 用于相机跟随、UI 更新等需要等待其他对象更新完成的操作
- **执行顺序**: Update → LateUpdate

## 四、动画系统阶段

### 7. 动画系统评估 (Animation Evaluation)
- **调用时机**: 在 LateUpdate 之后
- **特点**:
  - Unity 内部步骤，在工作线程中计算动画值
  - 计算 Transform（位置、旋转、缩放）
  - 计算其他属性（材质、灯光等）
- **执行顺序**: LateUpdate → 动画系统评估

### 8. Write Transform（写入变换）
- **调用时机**: 动画系统评估完成后
- **特点**:
  - Unity 内部步骤，将动画计算的 Transform 数据从工作线程写入到主线程
  - 更新场景中对象的 Transform 组件（position, rotation, scale）
  - 这是线程同步的关键步骤
- **执行顺序**: 动画系统评估 → Write Transform

### 9. WriteProperties（写入属性）
- **调用时机**: Write Transform 之后
- **特点**:
  - Unity 内部步骤，将其他动画属性值应用到相应组件
  - 更新材质属性、灯光强度等非 Transform 属性
- **执行顺序**: Write Transform → WriteProperties

### 10. OnAnimatorMove
- **调用时机**: Animator 处理完根运动后调用
- **特点**:
  - 在 WriteProperties 之后
  - 在 OnAnimatorIK 之前
  - 用于处理根运动（Root Motion）
  - **注意**: 如果实现了此方法，Unity 不会自动应用根运动，需要手动处理
- **执行顺序**: WriteProperties → OnAnimatorMove

### 11. OnAnimatorIK
- **调用时机**: Animator 的 IK（反向运动学）计算后调用
- **特点**:
  - 在 OnAnimatorMove 之后
  - 用于 IK 相关的处理
- **执行顺序**: OnAnimatorMove → OnAnimatorIK

## 五、渲染阶段

### 12. OnGUI
- **调用时机**: 每帧调用多次（用于渲染 GUI）
- **特点**:
  - 在渲染阶段调用
  - 可能在同一帧内调用多次
  - 用于 IMGUI 系统（OnGUI）
- **执行顺序**: 在渲染阶段

### 13. OnPreRender
- **调用时机**: 相机开始渲染场景前调用
- **特点**:
  - 需要挂载到有 Camera 组件的对象上
  - 在渲染前调用
- **执行顺序**: 渲染前

### 14. OnRenderObject
- **调用时机**: 每个可见对象渲染时调用
- **特点**:
  - 在渲染管线中调用
- **执行顺序**: 渲染中

### 15. OnPostRender
- **调用时机**: 相机完成场景渲染后调用
- **特点**:
  - 需要挂载到有 Camera 组件的对象上
  - 在渲染后调用
- **执行顺序**: OnPreRender → OnRenderObject → OnPostRender

## 六、协程

### 16. Coroutine (yield return null)
- **调用时机**: 在 Update 之后执行
- **特点**:
  - 使用 `yield return null` 会在下一帧的 Update 之后继续执行
  - 使用 `yield return new WaitForFixedUpdate()` 会在 FixedUpdate 之后执行
  - 使用 `yield return new WaitForEndOfFrame()` 会在帧结束后执行
- **执行顺序**: 
  - `yield return null`: Update 之后
  - `yield return new WaitForFixedUpdate()`: FixedUpdate 之后
  - `yield return new WaitForEndOfFrame()`: 帧结束后

## 七、物理碰撞事件

### 17. OnTriggerEnter / OnTriggerStay / OnTriggerExit
- **调用时机**: 触发器事件
- **特点**:
  - 需要至少一个对象有 `isTrigger = true`
  - 在物理更新后调用
- **执行顺序**: FixedUpdate → 物理计算 → OnTriggerEnter/Stay/Exit

### 18. OnCollisionEnter / OnCollisionStay / OnCollisionExit
- **调用时机**: 碰撞事件
- **特点**:
  - 需要两个非触发器的 Collider
  - 在 FixedUpdate 之后调用
- **执行顺序**: FixedUpdate → 物理计算 → OnCollisionEnter/Stay/Exit

## 八、清理阶段

### 19. OnDisable
- **调用时机**: 对象禁用时调用（每次禁用都会调用）
- **特点**:
  - 对象从激活状态变为禁用状态时调用
  - 在 OnDestroy 之前（如果对象被销毁）
  - 用于取消事件订阅、禁用组件等
- **执行顺序**: OnDisable → OnDestroy

### 20. OnDestroy
- **调用时机**: 对象销毁时调用
- **特点**:
  - 在 OnDisable 之后
  - 用于清理资源、取消订阅等
- **执行顺序**: OnDisable → OnDestroy

### 21. OnApplicationPause
- **调用时机**: 应用暂停时调用（移动平台）
- **特点**: 当应用失去焦点时调用

### 22. OnApplicationFocus
- **调用时机**: 应用焦点变化时调用
- **特点**: 当应用获得或失去焦点时调用

### 23. OnApplicationQuit
- **调用时机**: 应用退出时调用
- **特点**: 在编辑器停止播放或应用退出时调用

## 完整执行顺序（单帧）

```
场景启动/对象创建:
  Awake
    ↓
  OnEnable (首次激活)
    ↓
第一帧:
  Start
    ↓
  FixedUpdate (如果该帧需要)
    ↓
  Update
    ↓
  LateUpdate
    ↓
  动画系统评估 (Animation Evaluation)
    ↓
  Write Transform (Unity 内部：写入 Transform 数据)
    ↓
  WriteProperties (Unity 内部：写入其他属性)
    ↓
  OnAnimatorMove (如果有 Animator)
    ↓
  OnAnimatorIK (如果有 Animator 且启用 IK)
    ↓
  OnGUI (渲染阶段，可能多次)
    ↓
  OnPreRender (如果有 Camera)
    ↓
  OnRenderObject
    ↓
  OnPostRender (如果有 Camera)
    ↓
  Coroutine (yield return new WaitForEndOfFrame)
    ↓
物理事件 (在 FixedUpdate 之后):
  OnTriggerEnter/Stay/Exit
  OnCollisionEnter/Stay/Exit
```

## 注意事项

1. **Write Transform 和 WriteProperties**:
   - 这是 Unity 动画系统的内部步骤，用于将动画计算结果应用到场景
   - `Write Transform` 将 Transform 数据从工作线程同步到主线程
   - `WriteProperties` 将其他属性值应用到相应组件
   - 这两个步骤在 `LateUpdate` 之后、`OnAnimatorMove` 之前执行
   - 详细说明请参考 `动画系统内部流程说明.md`

2. **默认状态 vs 状态转换**: 
   - 默认状态的 AnimationEvent 可能在 OnStateEnter 之前触发
   - 状态转换时，OnStateEnter 在 AnimationEvent 之前触发

3. **FixedUpdate 与 Update 的关系**:
   - FixedUpdate 的时间步长固定，可能与 Update 不同步
   - 一帧内可能调用多次 FixedUpdate，也可能不调用

4. **协程的执行时机**:
   - `yield return null`: 在 Update 之后
   - `yield return new WaitForFixedUpdate()`: 在 FixedUpdate 之后
   - `yield return new WaitForEndOfFrame()`: 在帧结束后

5. **渲染相关方法**:
   - 需要挂载到有 Camera 组件的对象上才会调用
   - OnGUI 可能在同一帧内调用多次

## 测试方法

1. 运行场景
2. 打开 Console 窗口
3. 观察日志中的时间戳和帧数
4. 分析各生命周期的执行顺序


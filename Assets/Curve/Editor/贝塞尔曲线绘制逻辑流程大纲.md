# 贝塞尔曲线绘制逻辑流程大纲

## 概述

本文档描述在网格系统中绘制贝塞尔曲线的完整逻辑流程，包括曲线采样、坐标转换、可见性判断和绘制优化。

## 核心组件

### 1. 数据模型

#### BezierCurve（曲线数据）
- **控制点列表**：`List<BezierPoint> points`
- **循环标志**：`bool loop`（是否首尾相连）
- **分辨率**：`int resolution`（曲线采样点数）
- **方法**：
  - `Evaluate(float t)`：在参数 t 处求值曲线
  - `GetBounds()`：获取曲线边界框
  - `GetSegment(int index)`：获取指定段的三次贝塞尔曲线参数

#### BezierPoint（控制点）
- **位置**：`Vector2 position`（曲线空间坐标）
- **入切线**：`Vector2 inTangent`
- **出切线**：`Vector2 outTangent`
- **切线模式**：`TangentMode mode`

### 2. 数学计算

#### BezierMath（数学工具类）
- `EvaluateCubicBezier(p0, p1, p2, p3, t)`：计算三次贝塞尔曲线点
- `EvaluateCubicBezierTangent(...)`：计算切线方向
- `Subdivide(...)`：细分曲线段

## 绘制流程

### 阶段 1：准备阶段

#### 1.1 可见性判断
```
输入：BezierCurve, visibleBounds（可见区域）
输出：是否需要绘制

步骤：
1. 计算曲线的边界框（curveBounds）
2. 检查 curveBounds 是否与 visibleBounds 相交
3. 如果不相交，跳过绘制（性能优化）
```

#### 1.2 计算采样分辨率
```
输入：visibleBounds, zoom, settings.curveResolution
输出：实际采样点数

步骤：
1. 计算曲线在屏幕上的像素长度（近似）
2. 根据像素长度和缩放级别调整采样点数
3. 限制在合理范围内（如 10-500 点）
4. 公式：resolution = Clamp(pixelLength * zoom * quality, 10, 500)
```

### 阶段 2：曲线采样

#### 2.1 遍历曲线段
```
对于每条曲线段（segment）：
  1. 获取段的控制点：p0, p1, p2, p3
  2. 计算段在曲线空间中的范围
  3. 检查段是否在可见区域内
  4. 如果可见，进行采样
```

#### 2.2 自适应采样
```
对于每个曲线段：
  1. 计算段的长度（曲线空间）
  2. 根据长度和缩放级别决定采样点数
  3. 使用均匀采样或自适应采样
  4. 生成采样点列表
```

**采样策略：**
- **均匀采样**：简单快速，适合大多数情况
- **自适应采样**：根据曲率调整密度，弯曲处采样更密集

### 阶段 3：坐标转换

#### 3.1 曲线空间 → 屏幕空间
```
对于每个采样点：
  1. 获取曲线空间坐标（curvePoint）
  2. 使用 BezierCurveDrawer.CurveToScreen() 转换
  3. 得到屏幕坐标（screenPoint）
  4. 添加到屏幕点列表
```

#### 3.2 裁剪处理
```
对于转换后的点：
  1. 检查是否在屏幕区域内
  2. 如果不在，标记为裁剪点
  3. 记录裁剪边界，用于后续连接
```

### 阶段 4：绘制阶段

#### 4.1 绘制曲线
```
输入：屏幕点列表
输出：绘制的曲线

步骤：
1. 设置曲线颜色和宽度
2. 使用 Handles.DrawPolyLine() 或逐段绘制
3. 处理裁剪边界（连接可见部分）
4. 如果 loop = true，连接首尾点
```

#### 4.2 绘制控制点（可选）
```
对于每个控制点：
  1. 转换到屏幕坐标
  2. 检查是否在可见区域内
  3. 绘制控制点（圆形或方形）
  4. 如果选中，使用高亮颜色
```

#### 4.3 绘制切线（可选）
```
对于每个控制点：
  1. 计算切线在屏幕上的长度
  2. 绘制入切线和出切线
  3. 绘制切线控制点（如果可编辑）
```

## 详细实现步骤

### 步骤 1：DrawCurve 主方法

```csharp
public static void DrawCurve(BezierCurve curve, Rect area, BezierCurveSettings settings)
{
    // 1. 可见性判断
    if (!IsCurveVisible(curve, area, settings))
        return;
    
    // 2. 计算采样分辨率
    int resolution = CalculateResolution(curve, area, settings);
    
    // 3. 采样曲线点
    List<Vector2> curvePoints = SampleCurve(curve, resolution);
    
    // 4. 转换为屏幕坐标
    List<Vector2> screenPoints = ConvertToScreen(curvePoints, area, settings);
    
    // 5. 绘制曲线
    DrawCurveLines(screenPoints, settings);
}
```

### 步骤 2：可见性判断

```csharp
private static bool IsCurveVisible(BezierCurve curve, Rect area, BezierCurveSettings settings)
{
    // 获取曲线边界框（曲线空间）
    Rect curveBounds = curve.GetBounds();
    
    // 获取可见区域（曲线空间）
    Rect visibleBounds = GetVisibleBounds(area, settings);
    
    // 检查是否相交（添加容差）
    return curveBounds.Overlaps(visibleBounds);
}
```

### 步骤 3：计算采样分辨率

```csharp
private static int CalculateResolution(BezierCurve curve, Rect area, BezierCurveSettings settings)
{
    // 计算曲线在屏幕上的近似长度
    Rect curveBounds = curve.GetBounds();
    float curveLength = Mathf.Max(curveBounds.width, curveBounds.height);
    
    // 考虑缩放级别
    float screenLength = curveLength * settings.zoom * Mathf.Min(area.width, area.height);
    
    // 根据屏幕长度计算分辨率（每像素约 0.5-2 个点）
    int resolution = Mathf.RoundToInt(screenLength * 1.5f);
    
    // 限制在合理范围内
    return Mathf.Clamp(resolution, 10, settings.curveResolution);
}
```

### 步骤 4：曲线采样

```csharp
private static List<Vector2> SampleCurve(BezierCurve curve, int resolution)
{
    List<Vector2> points = new List<Vector2>(resolution);
    
    int segmentCount = curve.loop ? curve.pointCount : curve.pointCount - 1;
    
    for (int i = 0; i < segmentCount; i++)
    {
        // 获取段的控制点
        var segment = curve.GetSegment(i);
        
        // 计算段的采样点数
        int segmentResolution = resolution / segmentCount;
        
        // 采样段
        for (int j = 0; j <= segmentResolution; j++)
        {
            float t = (float)j / segmentResolution;
            Vector2 point = BezierMath.EvaluateCubicBezier(
                segment.p0, segment.p1, segment.p2, segment.p3, t);
            points.Add(point);
        }
    }
    
    return points;
}
```

### 步骤 5：坐标转换

```csharp
private static List<Vector2> ConvertToScreen(List<Vector2> curvePoints, Rect area, BezierCurveSettings settings)
{
    List<Vector2> screenPoints = new List<Vector2>(curvePoints.Count);
    
    foreach (var curvePoint in curvePoints)
    {
        Vector2 screenPoint = BezierCurveDrawer.CurveToScreen(curvePoint, area, settings);
        screenPoints.Add(screenPoint);
    }
    
    return screenPoints;
}
```

### 步骤 6：绘制曲线

```csharp
private static void DrawCurveLines(List<Vector2> screenPoints, BezierCurveSettings settings)
{
    if (screenPoints.Count < 2)
        return;
    
    // 设置曲线样式
    Handles.color = settings.curveColor;
    
    // 使用 Handles.DrawPolyLine 绘制（性能更好）
    Handles.DrawPolyLine(screenPoints.ToArray());
    
    // 或者逐段绘制（更灵活，可以处理裁剪）
    // for (int i = 0; i < screenPoints.Count - 1; i++)
    // {
    //     Handles.DrawLine(screenPoints[i], screenPoints[i + 1]);
    // }
}
```

## 优化策略

### 1. 可见性裁剪
- **曲线级别**：检查整个曲线边界框
- **段级别**：检查每个曲线段是否可见
- **点级别**：跳过屏幕外的点

### 2. 自适应采样
- **基于曲率**：弯曲处采样更密集
- **基于缩放**：缩放越大，采样越密集
- **基于屏幕大小**：屏幕越大，采样越多

### 3. 性能优化
- **LOD（细节层次）**：根据缩放级别调整采样密度
- **缓存采样点**：如果曲线未改变，重用采样结果
- **批量绘制**：使用 `Handles.DrawPolyLine` 而非逐段绘制

### 4. 视觉优化
- **抗锯齿**：使用 Unity 的 Handles 系统自动处理
- **线宽**：根据缩放级别调整线宽
- **颜色渐变**：可选，根据曲线参数使用不同颜色

## 绘制顺序

```
1. 绘制网格背景
2. 绘制坐标轴
3. 绘制曲线（在网格之上）
4. 绘制控制点（在曲线之上）
5. 绘制切线（在控制点之上）
6. 绘制选中高亮（最上层）
```

## 交互集成

### 与网格系统的集成
- 曲线点使用曲线空间坐标
- 通过 `CurveToScreen` 转换显示
- 支持缩放和平移操作

### 与交互系统的集成
- 控制点选择使用屏幕坐标
- 拖拽时实时更新曲线
- 切线编辑影响相邻段

## 待实现功能

### 基础功能
- [ ] 曲线采样和绘制
- [ ] 可见性判断
- [ ] 坐标转换集成

### 高级功能
- [ ] 自适应采样
- [ ] 曲线裁剪优化
- [ ] 控制点和切线绘制
- [ ] 选中高亮
- [ ] 曲线样式（虚线、渐变等）

### 性能优化
- [ ] 采样点缓存
- [ ] LOD 系统
- [ ] 批量绘制优化

## 注意事项

1. **坐标空间一致性**：确保所有计算都在曲线空间中进行
2. **性能考虑**：避免在每帧重新采样，使用缓存
3. **精度问题**：浮点数计算可能导致采样点不连续
4. **循环曲线**：需要特殊处理首尾连接
5. **切线连续性**：确保相邻段的切线连续

## 参考实现

- Unity AnimationCurve 编辑器
- Unity Timeline 曲线编辑器
- 其他开源贝塞尔曲线编辑器




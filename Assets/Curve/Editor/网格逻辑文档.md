# 网格绘制系统逻辑文档

## 概述

网格绘制系统基于曲线空间坐标，支持缩放和平移操作。网格在曲线空间中的大小固定，缩放时在屏幕上的显示会自然变化，确保网格始终显示为正方形（1:1 比例）。

## 核心概念

### 坐标空间

1. **曲线空间（Curve Space）**
   - **定义**：曲线的逻辑坐标空间，用于描述曲线和控制点的实际位置
   - **范围**：由 `viewBounds` 定义（例如：`Rect(0, 0, 1, 1)` 表示从 (0,0) 到 (1,1) 的区域）
   - **特点**：
     - 独立于屏幕显示，不受窗口大小影响
     - 网格步长在此空间中定义（如 0.05 单位）
     - 曲线点的坐标使用此空间（如控制点位置 (0.2, 0.8)）
   - **示例**：
     - 如果 `viewBounds = Rect(0, 0, 1, 1)`，则曲线空间范围是 X: [0, 1], Y: [0, 1]
     - 如果 `viewBounds = Rect(-1, -1, 2, 2)`，则曲线空间范围是 X: [-1, 1], Y: [-1, 1]
   - **用途**：存储曲线的真实数据，不随视图变化而改变

2. **视图空间（View Space）**
   - **定义**：归一化的 [0,1] 空间，用于视图变换
   - **特点**：
     - 将曲线空间坐标归一化到 [0,1] 范围
     - 在此空间应用缩放和平移变换
     - 作为曲线空间和屏幕空间之间的中间层

3. **屏幕空间（Screen Space）**
   - **定义**：Unity 编辑器的像素坐标
   - **特点**：
     - Y 轴向下（与数学坐标系相反）
     - 坐标单位是像素
     - 受窗口大小和位置影响

### 坐标转换

#### 曲线空间 → 屏幕空间

```csharp
// 1. 归一化到视图空间
viewPoint = (curvePoint - viewBounds.min) / viewBounds.size

// 2. 应用缩放（以中心为基准）
viewPoint = (viewPoint - 0.5) * zoom + 0.5

// 3. 应用平移
viewPoint += panOffset

// 4. 映射到屏幕坐标（Y轴翻转）
screenX = Lerp(screenRect.xMin, screenRect.xMax, viewPoint.x)
screenY = Lerp(screenRect.yMax, screenRect.yMin, viewPoint.y)
```

#### 屏幕空间 → 曲线空间

逆变换过程，按相反顺序执行上述步骤。

## 网格绘制逻辑

### 1. 计算可见区域

将屏幕区域的四个角点转换为曲线空间坐标，计算可见区域的边界：

```csharp
Rect visibleBounds = GetVisibleBounds(area, settings)
```

### 2. 计算网格步长

网格步长计算分为两个步骤：

#### 2.1 自适应基础步长

根据缩放级别和可见区域大小动态调整基础网格步长：

```csharp
// 计算可见区域大小
visibleSize = viewBounds.size / zoom

// 使用对数尺度计算自适应步长
logScale = Log10(visibleSize)
normalizedLog = (logScale + 3) / 4  // 映射到 [0, 1]
adaptiveStep = Lerp(MIN_GRID_STEP, MAX_GRID_STEP, normalizedLog)

// 结合网格线数量限制
stepForMaxLines = visibleSize / MAX_GRID_LINES
adaptiveStep = Max(adaptiveStep, stepForMaxLines)
adaptiveStep = Min(adaptiveStep, visibleSize / MIN_GRID_LINES)
```

**自适应逻辑：**
- **缩放很大时**（zoom > 1）：可见区域小，步长自动减小（最小 0.005），网格更精细
- **缩放很小时**（zoom < 1）：可见区域大，步长自动增大（最大 0.5），避免过密
- **网格线数量限制**：确保每个方向在 5-50 条线之间

#### 2.2 应用宽高比调整

为了确保网格在屏幕上显示为正方形，需要根据屏幕和视图的宽高比调整步长：

```csharp
viewAspectRatio = viewBounds.width / viewBounds.height
screenAspectRatio = area.width / area.height
stepRatio = viewAspectRatio / screenAspectRatio

gridStepX = adaptiveStep
gridStepY = adaptiveStep / stepRatio
```

**原理说明：**

网格在屏幕上的像素数计算公式：
- 水平方向：`(gridStepX / viewBounds.width) * zoom * area.width`
- 垂直方向：`(gridStepY / viewBounds.height) * zoom * area.height`

要让网格显示为正方形，需要：
```
(gridStepX / viewBounds.width) * area.width = (gridStepY / viewBounds.height) * area.height
```

简化后：
```
gridStepX / gridStepY = (viewBounds.width / viewBounds.height) / (area.width / area.height)
```

### 3. 对齐到网格

将可见区域边界对齐到网格步长的整数倍：

```csharp
startX = Floor(minX / gridStepX) * gridStepX
startY = Floor(minY / gridStepY) * gridStepY
endX = Ceil(maxX / gridStepX) * gridStepX
endY = Ceil(maxY / gridStepY) * gridStepY
```

### 4. 绘制网格线

- **垂直网格线**：在曲线空间中按 `gridStepX` 步长绘制
- **水平网格线**：在曲线空间中按 `gridStepY` 步长绘制
- 只绘制在可见区域内的线（添加容差以避免边界问题）

### 5. 绘制零线

如果 X=0 或 Y=0 在可见区域内，绘制高亮的零线：
- 对齐到最近的网格线
- 使用半透明白色（alpha = 0.3）

## 关键参数

### 基础参数
- `BASE_GRID_STEP = 0.05f`：基础网格步长（曲线空间单位）
- `ZERO_LINE_ALPHA = 0.6f`：坐标轴透明度（值越大越明显）
- `GRID_CLIP_TOLERANCE = 1f`：网格裁剪容差（像素）

### 自适应网格密度参数
- `MIN_GRID_STEP = 0.005f`：最小网格步长（缩放很大时，更精细）
- `MAX_GRID_STEP = 0.5f`：最大网格步长（缩放很小时，避免过密）
- `MAX_GRID_LINES = 50`：每个方向最大网格线数量（性能优化）
- `MIN_GRID_LINES = 5`：每个方向最小网格线数量（避免过疏）

## 性能优化

1. **只在 Repaint 事件时绘制**：避免在 Layout 事件中重复绘制
2. **裁剪不可见网格线**：只绘制在可见区域内的线
3. **使用常量**：避免重复计算
4. **自适应网格密度**：根据缩放级别动态调整网格步长，避免绘制过多网格线
5. **限制最大网格线数量**：每个方向最多 50 条线，确保性能

## 缩放和平移

### 缩放

- 以鼠标位置为中心进行缩放
- 缩放时自动调整 `panOffset`，使鼠标指向的曲线空间位置保持不变
- 网格在曲线空间中的大小不变，在屏幕上的显示会变化

### 平移

- 拖动方向与鼠标移动方向一致
- 平移时网格会跟着移动
- `panOffset` 在视图空间中累加

## 使用示例

```csharp
// 在 EditorWindow 的 OnGUI 中调用
if (Event.current.type == EventType.Repaint)
{
    BezierCurveDrawer.DrawGrid(m_CurveArea, m_Settings);
}
```

## 注意事项

1. 网格步长在曲线空间中定义，不受缩放影响
2. 网格始终显示为正方形，无论屏幕或视图的宽高比如何
3. 零线会自动对齐到网格，确保视觉一致性
4. 坐标转换需要考虑 Y 轴翻转（屏幕 Y 向下，视图 Y 向上）


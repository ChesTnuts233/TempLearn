# 曲线空间坐标说明

## 什么是曲线空间坐标？

**曲线空间坐标**是用于描述曲线和控制点位置的逻辑坐标系统，它独立于屏幕显示，类似于数学坐标系。

## 为什么需要曲线空间坐标？

### 问题场景

想象你在 Unity 编辑器中编辑一条贝塞尔曲线：

1. **窗口大小会变化**：用户可能调整窗口大小
2. **需要缩放和平移**：用户需要放大查看细节，或平移查看不同区域
3. **数据需要持久化**：曲线的控制点位置需要保存，不应该受窗口大小影响

如果直接使用屏幕坐标（像素），会遇到这些问题：
- 窗口大小改变时，曲线位置会错乱
- 无法实现缩放和平移
- 数据无法在不同分辨率下正确显示

### 解决方案

使用**曲线空间坐标**作为数据的逻辑表示，然后通过坐标转换显示到屏幕上。

## 曲线空间的定义

曲线空间由 `viewBounds` 定义，它是一个 `Rect` 结构：

```csharp
public Rect viewBounds = new Rect(0, 0, 1, 1);
```

这个 `Rect` 表示：
- `x, y`：曲线空间的原点（左下角）
- `width, height`：曲线空间的范围

### 示例

**示例 1：标准范围**
```csharp
viewBounds = new Rect(0, 0, 1, 1)
```
- X 轴范围：[0, 1]
- Y 轴范围：[0, 1]
- 这是一个 1×1 的正方形区域

**示例 2：更大的范围**
```csharp
viewBounds = new Rect(-2, -2, 4, 4)
```
- X 轴范围：[-2, 2]
- Y 轴范围：[-2, 2]
- 这是一个 4×4 的正方形区域，中心在原点

**示例 3：非正方形范围**
```csharp
viewBounds = new Rect(0, 0, 2, 1)
```
- X 轴范围：[0, 2]
- Y 轴范围：[0, 1]
- 这是一个 2×1 的矩形区域（宽是高的 2 倍）

## 坐标转换流程

### 曲线空间 → 屏幕空间

```
曲线空间坐标 (0.5, 0.5)
    ↓ [归一化]
视图空间坐标 (0.5, 0.5)  // 在 viewBounds 中的相对位置
    ↓ [应用缩放]
视图空间坐标 (0.5, 0.5)  // 如果 zoom=1，不变
    ↓ [应用平移]
视图空间坐标 (0.5, 0.5)  // 如果 panOffset=(0,0)，不变
    ↓ [映射到屏幕]
屏幕坐标 (300, 200)      // 假设窗口大小是 600×400
```

### 具体转换公式

```csharp
// 1. 归一化到视图空间
viewPoint = (curvePoint - viewBounds.min) / viewBounds.size

// 2. 应用缩放（以中心为基准）
viewPoint = (viewPoint - 0.5) * zoom + 0.5

// 3. 应用平移
viewPoint += panOffset

// 4. 映射到屏幕坐标
screenX = Lerp(screenRect.xMin, screenRect.xMax, viewPoint.x)
screenY = Lerp(screenRect.yMax, screenRect.yMin, viewPoint.y)  // Y轴翻转
```

## 实际例子

### 例子 1：基本显示

假设：
- `viewBounds = Rect(0, 0, 1, 1)`
- `zoom = 1.0`
- `panOffset = (0, 0)`
- 屏幕区域 = `Rect(0, 0, 600, 400)`

曲线空间坐标 `(0.5, 0.5)` 会显示在屏幕的 `(300, 200)` 位置（中心）。

### 例子 2：缩放

假设：
- `viewBounds = Rect(0, 0, 1, 1)`
- `zoom = 2.0`  // 放大 2 倍
- `panOffset = (0, 0)`
- 屏幕区域 = `Rect(0, 0, 600, 400)`

曲线空间坐标 `(0.5, 0.5)` 仍然显示在屏幕中心，但可见区域缩小了：
- 可见的曲线空间范围：X: [0.25, 0.75], Y: [0.25, 0.75]

### 例子 3：平移

假设：
- `viewBounds = Rect(0, 0, 1, 1)`
- `zoom = 1.0`
- `panOffset = (0.1, 0.1)`  // 向右上平移
- 屏幕区域 = `Rect(0, 0, 600, 400)`

曲线空间坐标 `(0.5, 0.5)` 会显示在屏幕的 `(360, 240)` 位置（向右上偏移）。

## 曲线空间坐标的优势

1. **数据独立性**：曲线数据不依赖窗口大小
2. **支持缩放**：可以放大查看细节，缩小查看全貌
3. **支持平移**：可以移动视图查看不同区域
4. **易于计算**：网格步长、控制点位置都在逻辑空间中定义
5. **可移植性**：数据可以在不同分辨率的屏幕上正确显示

## 常见问题

### Q: 为什么网格步长是 0.05？

A: 0.05 是在曲线空间中的单位。如果 `viewBounds = Rect(0, 0, 1, 1)`，那么 0.05 表示整个范围的 5%，这样网格不会太密集也不会太稀疏。

### Q: 如何改变曲线空间的范围？

A: 修改 `viewBounds`。例如，如果要显示更大的范围：
```csharp
settings.viewBounds = new Rect(-5, -5, 10, 10);  // 显示 -5 到 5 的范围
```

### Q: 曲线空间坐标和世界坐标有什么区别？

A: 
- **曲线空间坐标**：用于编辑器内部，描述曲线在编辑器中的逻辑位置
- **世界坐标**：Unity 场景中的实际坐标，用于游戏运行时

两者是不同的概念，曲线空间坐标主要用于编辑器的显示和编辑。

## 总结

曲线空间坐标是一个**逻辑坐标系统**，用于：
- 存储曲线的真实数据
- 支持缩放和平移操作
- 独立于屏幕显示

通过坐标转换，曲线空间坐标被映射到屏幕坐标进行显示，这样就能实现灵活的视图操作，同时保持数据的稳定性。

